Lecture: Algorithms on Arrays (Rotate)
========================================

* Rotation
    * Used in sorting algorithms.
    * Used in text editors, e.g., when you drag-and-drop a chunk of text to a new location.    
    * Discussed in "Programming Pearls" pp. 13-15, 209-211 by Jon Bentley
       (won the Dr. Dobb's Excellence in Programming award in 2004,
        Prof. at CMU whose students include Gosling (invented Java), Leiserson, 
        Later went to Bell Labs)
    * terms: block-swapping, block exchange, section swap, vector rotation

    (Other references   
    "Benchmarking Block-Swapping Algorithms" by Victor Duvanenko, Dr. Dobb's 2012
    http://www.drdobbs.com/parallel/benchmarking-block-swapping-algorithms/232900395
    "Swapping Sections" by David Gries and Harlan)
    
  * Rotation by 1 to the right (warm up)
    How to rotate elements on an array to the right by 1, with wrap-around?
    [1,2,3,4,5] => [5,1,2,3,4]

    ***** Student group project: pair-up, write python solution on 3x5" card

    * Save and shift
       [1,2,3,4,5]
       [1,2,3,4,-], 5    (put 5 off to the side)
       [-,1,2,3,4], 5    (move everything else to the right)
       [5,1,2,3,4]       (put 5 at the front)

       When moving everything to the right, should you go forwards or backwards?
       Answer: It's easier to go backwards.

       def rotate_1_save_n_shift(A):
           if len(A) <= 1:
               return
           else:
               last = A[len(A)-1]
               for i in range(len(A)-1,0,-1):
                   A[i] = A[i-1]
               A[0] = last

    * Ripple from start (think of flapping a bedsheet)
       [1,2,3,4,5]
       [-,2,3,4,5],1
       [-,1,3,4,5],2
       [-,1,2,4,5],3
       [-,1,2,3,5],4
       [-,1,2,3,4],5
       [5,1,2,3,4]

       def rotate_1_ripple(A):
           if len(A) <= 1:
               return
           else:
               tmp1 = A[0]
               for i in range(0,len(A)-1):
                   tmp2 = A[i+1]
                   A[i+1] = tmp1
                   tmp1 = tmp2
               A[0] = tmp1

    * Ripple from end
       [1,2,3,4,5]
       [1,2,3,4,-],5
       [5,2,3,4,-],1
       [5,1,3,4,-],2
       [5,1,2,4,-],3
       [5,1,2,3,-],4
       [5,1,2,3,4]

    * Ripple from start by swapping with A[0]
                          [1,2,3,4,5]
       [1,2,3,4,5]        [-,2,3,4,5],1
       [2,1,3,4,5]        [-,1,3,4,5],2
       [3,1,2,4,5]        [-,1,2,4,5],3
       [4,1,2,3,5]        [-,1,2,3,5],4
       [5,1,2,3,4]        [-,1,2,3,4],5
                          [-,1,2,3,4],5

       def swap(A, i, j):
           tmp = A[i]
           A[i] = A[j]
           A[j] = tmp

       def rotate_1_ripple_swap(A):
           if len(A) <= 1:
               return
           else:
               for i in range(1,len(A)):
                   swap(A, 0, i)

   * Ripple from end swapping with A[4]
       [1,2,3,4,5]        [1,2,3,4,-],5
       [5,2,3,4,1]        [5,2,3,4,-],1
       [5,1,3,4,2]        [5,1,3,4,-],2
       [5,1,2,4,3]        [5,1,2,4,-],3
       [5,1,2,3,4]        [5,1,2,3,-],4
                          [5,1,2,3,4]

    * Swap backwards
       [1,2,3,4,5]
       [1,2,3,5,4]
       [1,2,5,3,4]
       [1,5,2,3,4]
       [5,1,2,3,4]

       def rotate_1_swap_bkwd(A):
           if len(A) <= 1:
               return
           for i in range(len(A)-1, 0, -1):
               swap(A, i, i-1)

  * Rotation by 1 to the left

    * Swap forwards
       [1,2,3,4,5]
       [2,1,3,4,5]
       [2,3,1,4,5]
       [2,3,4,1,5]
       [2,3,4,5,1]

  * Rotation by k to the right
    * Example k=2
      [1,2,3,4,5,6] ==> [5,6,1,2,3,4]

    * Example k=3
      [1,2,3,4,5,6] ==> [4,5,6,1,2,3]

    * Example k=4
      [1,2,3,4,5,6] ==> [3,4,5,6,1,2]

    * Rotate by 4 to the right is the same
      as rotate by 2 to the left.

    * In general: can think of it as switching location of diff. sized blocks
      |---- a ----|-- b --|
      0           m       n   where m = n - k
      =>
      |-- b --|---- a ----|

    * Tools
      * swap_range : swaps two equal-length ranges
      * reverse : reverses in-place 

    * Naive solutions:
      * rotate by 1, k times. Too slow: O(n^2).
      * copy k-length chunk to auxilliary memory, move the rest over, copy back.
        Too much memory: O(n).

    ***** Student group project: pair-up, brain-storm solutions

    * Better solutions:
      * Successive Swapping [Gries and Mills, 1981]
        * Inspired by the swap-forwards algorithm for rotate left by 1
           and by ripple from the end for rotate to the right by 1.

           k=4 (like k=2 to the left)
           swap forwards
           [1,2,3,4,5,6]
            --- ---
           [3,4,1,2,5,6]
                --- ---
           [3,4,5,6,1,2]

           Ripple from the end
           k=2
           [1,2,3,4,5,6]
            ---     ---
           [5,6,3,4,1,2]
                --- ---
           [5,6,1,2,3,4]

        * Or can think of it as a divide and conquer algorithm.

          * Case 1: left side is smaller

            |----|--------|
            s    m        e
            
            do a swap_range with as much as you can
            |====|====|----|
            s    m         e

                 recursively process the rest
                 |----|-----|
                 s    m     e

            (This is really swap forwards.) 

          * Case 2: right side is smaller

            |--------|----|
            s        m    e

            do a swap_range with as much as you can
            |====|----|====|
            s         m    e

                 recursively process the rest
                 |----|----|
                 s    m    e

            (This is really ripple from the end.)

        Analysis:
          * worst case time complexity?
            * Not as straightforward, think about how much work is done
              for each element of output.
            * We move 2 things for each output
            * Output is O(n), and O(2*n) is still O(n)
            * So the time complexity is O(n)
          * space? no extra space, O(1)

      * Three reverses (I didn't have time for this.)
        (folk lore even back in 1971, used in the TERAK text editor)

        |-- a --|---- b ----|
        0       m           n
        =>
        |---- b ----|-- a --|

        rev(append(rev(a), rev(b))) = append(b, a)

        Analysis: 
          * worst case time complexity?
            reverse is O(n)
            and O(3*n) = O(n)
            so rotate_k_three_reverse is O(n)
          * space? no extra space, O(1)

      * Dolphin algorithm (Juggling) [Fletcher and Silver, 1966]

      * Can it be done in the style of the ripple swap? (I don't know.)
    
      ***** Student group project: pair-up, implement rotate_k in python

      * Here's successive_swap in Python

        def rotate_k_succ_swap(A, start, mid, end):
            l1 = mid - start
            l2 = end - mid
            swap_range(A, start, mid, min(l1,l2))
            if l1 == l2:
                return
            elif l1 > l2:
                rotate_k_succ_swap(A, start + l2, mid, end)
            else: # l1 < l2
                rotate_k_succ_swap(A, mid, mid + l1, end)

        def rotate_k_successive_swap(A, k):
            rotate_k_succ_swap(A, 0, len(A) - k, len(A))

     * Here's three_reverse in Python

        def rotate_k_three_reverse(A, k):
            n = len(A)
            m = n - k
            reverse(A, 0, m)
            reverse(A, m, n)
            reverse(A, 0, n)
