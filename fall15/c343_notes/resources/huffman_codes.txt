Lecture: Greedy algorithms and Huffman codes
============================================

* Activity Selection Problem
    Fit the maximum number of weddings into
    a single wedding hall over a period of 20 hours,
    given that each wedding has a particular
    requested start and end time.

    0         5        10        15        20
    |         |         |         |         |
    |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|   acitivity #
                                          0,0   0
      ------                              1,4   1
          ----                            3,5   2
    ------------                          0,6   3
              ----                        5,7   4
          ------------                    3,9   5
              --------                    5,9   6
                --------                  6,10  7
                    ------                8,11  8
                    --------              8,12  9
        ------------------------          2,14  10
                            --------      12,16 11

  - How would we formulate this as a dynamic programming
    problem?
    1. Choose an activity a_i, which start s_i, finish f_i
    2. Then solve the subproblems for [0,s_i) and [f_i,n).
    3. Do the same for the other activities, and go
       with the best one.

  - Can we make a "best" choice without seeing the results for the subproblems?
    * What if we work from left to right?
    * Pick the activity that finishes first thereby leaving the most
      time to other activities.

    Proof that the greedy choice is optimal:
    Suppose that we have an optimal solution, a set of activities A.
    If the activity to finish first is in A, then we are done.
    On the other hand, suppose the activity a to finish first is not in A.
    Let a' be the first activity to finish amongst those in A.
    We can replace a' with a to get a new solution. That is,
    let A' = A - {a'} U {a}. Then A' is a proper solution because
    the finish time of a is less than that of a', and therefore, less
    than that of any other activity in A.

  - Code for the greedy activity selector

    # s: start time, f: finish time, 
    # k: finished up through k'th activity, n: number of activities
    def activity_selector(s, f, k, n):
       m = k + 1
       while m <= n and s[m] < f[k]:   # skip over the act. that start too soon
          m += 1
       if m <= n:
          return activity_selector(s, f, m, n).append(m)
       else:
          return []

    To transform this into a loop, we can first make this
    a tail recursive function by adding an accumulator.

    def activity_selector_tr(s, f, k, n, acc):
       m = k + 1
       while m <= n and s[m] < f[k]:
          m += 1
       if m <= n:
          acc.append(m)
          return activity_selector_tr(s, f, m, n, acc)
       else:
          return acc

    Next we change the tail recursion into a loop:

    def activity_selector_iter(s, f, n):
       acc = []
       k = 0
       while True:
          m = k + 1
          while m <= n and s[m] < f[k]:
             m += 1
          # s[m] >= f[k]
          if m <= n:
             acc.append(m)
             k = m
          else:
             break
       return acc


    The two loops can be flattened into a single loop:

    def greedy_activity_selector(s, f, n):
       acc = []
       k = 0
       for m in range(1,n+1):
          if s[m] >= f[k]:
             acc.append(m)
             k = m
       return acc

* Greedy Algorithms in General
  - Greedy-choice property:
    a best choice can be determined without knowing the
    best solutions to subproblems.
  - Optimal substructure:
    an optimal solution contains optimal solutions to subproblems

* Huffman Codes

  - We've got a long DNA sequence and want to store it using less space:
    CTCT CTCT CTCT AGCT AGCC AGCC TGAA CATC CATC CTCT CATC
  - Use shorter binary codes for higher-frequency words
    CTCT: 4 occurrences
    CATC: 3
    AGCC: 2
    AGCT: 1
    TGAA: 1

  - To avoid needing a separator, use prefix codes. That is,
    make sure that no code is a prefix of another code.
    
    The parsing algorithm is: read the first code, then the second, and so on.

    To parse an individual code, use a Finite-State Automata in the
    shape of a tree
     
              _______
            0/       \1
            /         \
           |_         _|
         0/  \1     0/  \1
         /    \     /    \   
       0/\1  0/\1 0/\1  0/\1
       A  B  C  D E  F  G  H

  - Fixed-length versus variable length encodings

   A:10, B:1, C:1, D:2, E:6, F:2, G:1, H:1
   fixed-length uses 3 bits, A=000, B=001, C=010, D=011, etc.
   24 total characters in the string to be encoded
   With fixed length, total is 72.

   A=0(1), B=11000(5), C=11001(5), D=1101(4), 
      E=10(2), F=1110(4), G=11110(5), H=11111(5)
   Code-length multiplied times number of occurences, for each letter:
   A=10, B=5, C=5, D=8, E=12, F=8, G=5, H=5
   With variable length, total is 58.

   In general, the total number of bits B to encode a string using tree T
   is given by

   B(T) = \Sum_{c\in C} freq(c) * d_T(c)          
       where d_T(c) is the depth of c in the tree T.
   
  - Greedy algorithm:
    We work from back to front, choosing which
    bits for which words. We want to pick the lowest frequency
    words, because the longest codes go the farthest back.

    Intuition: make the choice that uses the fewest bits for the
      final encoded string.

    1. Put the words (singleton trees) into a min priority queue keyed by
       frequency.
    2. Pop two trees from the queue, create a subtree whose frequency
      is the sum of the two:
         2
         |- B[1]
         |- C[1]
    3. Push the new subtree into the queue.
    4. Go back to 2. as long as there is more than one item in the queue. 

       24
       |-A[10]
       |-14
	 |-E[6]
	 |-8
	   |-4
	   | |-2
	   | | |- B[1]
	   | | |- C[1]
	   | |-D[2]
	   |-4
	     |-F[2]
	     |-2
	       |- G[1]
	       |_ H[1]

  - How to encode a string using a Huffman code:

    * Build a dictionary mapping each word to its code.
      - recursively walk through the tree, keeping track
        of the current path, and add to the dictionary
        when you get to a leaf.

    * Iterate through the string and translate each word
      by using the dictionary.

   **** Student group work: 

     1. Create the Huffman code (tree)
        for the following alphabet with frequencies.

     a  b  c  d  e f
     ---------------
     45 13 12 16 9 5
   
     2. Write functions for decoding a string according
        to a Huffman tree.

