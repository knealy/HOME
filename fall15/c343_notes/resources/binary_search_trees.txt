Lecture: Binary Search Trees
============================

Overview:
* Project 3, segment intersection
* tree_search
* tree_minimum
* tree_after (aka successor), tree_before (aka predecessor)
* delete a node
* tree walking
  - pre/in/post-order
  - stack-based implementation
  - state-machine implementation using parent pointers

* Taking stock with respect to Flood-it!

                   |  Array | Linked List | Sorted Array
  membership test  |  O(n)  |  O(n)       |  O(lg n)
  insertion        |  O(1)  |  O(1)       |  O(n)

  * How do we keep the array sorted when inserting more elements?
    (use binary search for insertion)
    What's the time complexity?
    O(n) because we still have to shift elements down.

  * We'd like something that can do both membership test and insertion in
  O(lg n).

* Introduce Project 3, Segment Intersection. (33.2) Demo the solution.
  Given a set of n segments, are their any pairs that intersect?
    Suppose we have a routine for testing whether 2 segments intersect.

  * Simplifications:
    * No vertical segments
    * No three-way (or more) intersections

  * Brute force: test all combinations O(n^2)

  * Line sweep:
    * Sort all the end-points of the line segments from left to right (x-axis)
    * Move the line sweep from left to right, stopping at each end point.
    * Maintain a BST of all the segments that intersect the sweep line, sorted
      by where they cross the sweep line when they are first added to the BST.
    * We maintain the invariant that each segment in the BST does not
      intersect with the segment before it and the segment after it in
      the BST.
    * When you add a segment to the BST, check whether it intersects with
      the one before and the one after it in the BST. If it does, stop.
    * When you remove a segment from the BST, check whether the
      segment before it intersects with the segment after it.

  We'll need fast membership testing, insert, remove, and before/after.

* Quick discussion of unit testing

* Can we create a hybrid of the sorted array and the linked list?
  Yes: binary search trees!
   (to do: come up with a better tree to be the running-example)

          8
        /  \
       /    \
      3     10
     / \      \
    1   6      14
       / \    /
      4   7  13

  The Binary-Search-Tree Property:
    For every node x in the tree,
    1) if node y is in the left subtree of x, then y.key <= x.key, and
    2) if node z is in the right subtree of x, then x.key <= z.key.

  class BSTNode:
      def __init__(self, key, left=None, right=None):
          self.key = key
          self.left = left
          self.right = right

  class BinarySearchTree:
      def __init__(self, root = None):
          self.root = root

* We can perform membership tests as follows
  Discuss why we return a node whether or not
  we find a match.

    def tree_search_nonempty(n, k, less):
        if less(k, n.key):
            if n.left:
                return tree_search_nonempty(n.left, k, less)
            else:
                return n
        elif less(n.key, k):
            if n.right:
                return tree_search_nonempty(n.right, k, less)
            else:
                return n
        else:
            return n

    def tree_search(T, k):
        if T.root:
            return tree_search_nonempty(T.root, k, T.less)
        else:
            return T.root


  Example: Search for 6, 9, 15 in the below tree.

          8
        /  \
       /    \
      3     10
     / \      \
    1   6      14
       / \    /
      4   7  13


  What is the time complexity? answer: O(h), h is the height of the tree

**** Student group work: insert into a tree (hint: use tree_search)
  What is the time complexity? answer: O(h)
  To handle duplicates, can re-start the tree_search from the right
  child and keep going until you get a node without a child.

* (Gearing up towards the after/before ops and the delete operation)
  Find the node with the smallest key within a specified subtree.
  Example: what's the minimum of the above tree? answer: 1
    What's the minimum of the subtree rooted at 6? answer: 4

  def tree_minimum(n):
      if n.left:
          return tree_minimum(n.left)
      else:
          return n

* Student group work: given a node n, find the nearest ancestor with
  a greater key than n, if there is one.
  You may assume that each node has a parent attribute.

  def greater_ancestor(n):
      p = n.parent
      if p and n == p.right:
          return greater_ancestor(p)
      else:
          return p

***** Student group work: how to find the node with the next larger key?
  Example: What is after 3? Answer: 4.
  What is after 7? Answer: 8.

  Solution:
  def tree_after(n):
      if n.right:
          return tree_minimum(n.right)
      else:
          return greater_ancestor(n)

  What is the time complexity? answer: O(h)

* Transplant the subtree rooted at v into the location of u:
  There are three scenarios to consider:
  1. u is the root
  2. u is the left child of it's parent
  3. u is the right child of it's parent

  def transplant(T, u, v):
      if not u.parent:
          T.root = v
      elif u == u.parent.left:
          u.parent.left = v
      else:
          u.parent.right = v
      if v:
          v.parent = u.parent

* Delete node z

  * Case 1: (no left child)

      |              |
    z=o              A
       \       ==>   
        A

  * Case 2: (no right child)
        |            |
      z=o            A
       /       ==>
      A

  * Case 3: Two children
         |
       z=o
        / \
       A   B

    * The main idea is to replace z with the node after z, which
      is the minimum node y in subtree B.

      Two cases to consider:
      Case a) B is y

             |                  |
           z=o        ==>       y
            / \                / \
           A   y              A   C
                \
                 C

      Case b) B is not y (y is properly inside B)
        
             |                  |
           z=o        ==>       y
            / \                / \
           A   B             A    B
              ...                ...
               |                  |
               y                  C
                \
                 C      
                 
  What is the time complexity? answer: O(h)


* We can visit the keys in sorted-order by doing an *in-order*
  traversal of the tree.  There are also *pre-order* and *post-order*
  traversals, all of which can be combined into one function.

       6
      / \
     /   \
    5     7
   / \     \
  2   5     8

  pre:  6,5,2,5,7,8
  in:   2,5,5,6,7,8
  post: 2,5,5,8,7,6

  Answer question from last lecture: insert 5 into the above tree.

  **** Student group work. Write an in_order_walk (recursive) function
   that prints all the key's in the tree according to an
   in-order traversal.

   answer

  def in_order_nonempty(n):
      if n.left:
          in_order_nonempty(n.left)
      print(n.key)
      if n.right:
          in_order_nonempty(n.right)

  def in_order_tree_walk(T):
      if T.root:
          in_order_nonempty(T.root)

* For processing very large, unbalanced trees we need to avoid using
  Python's procedure call stack, which has a limit (default is 1000), and
  instead use an explicit stack. The trick is to break up the code
  into states that include the code between the recursive calls. We'll call the
  state before the first call the 'pre' state, the second the
  'in' state, and the third the 'post' state.
  
  def in_order_tree_walk_stack(T):
      if not T.root:
          return
      stack = ArrayStack()
      stack.push(('pre', T.root))
      while not stack.is_empty():
          (state,n) = stack.pop()
          if state == 'pre':
              stack.push(('in',n))
              if n.left:
                  stack.push(('pre', n.left))
          elif state == 'in':
              print(n.key)
              stack.push(('post',n))
              if n.right:
                  stack.push(('pre', n.right))
          else: # state == 'post'
              pass

* Instead of a stack, we can do even better if we have
  a way to get the parent of a node. We can create the
  following state machine that tells us where to
  go based on the current state and the shape of the tree.

  Case 1:  | pre    |  in      |   post
           |        |          |
     |     |        |          |   ^
     *     | <- pre |  -> pre  |   | (see below)
    / \    |        |          |
  ----------------------------------------
  Case 2:  |        |          |
     |     |        |          |   ^
     *     | <- pre |  - post  |   | (see below)
    /      |        |          |
  ----------------------------------------
  Case 3:  |        |          |
     |     |        |          |   ^
     *     | - in   | -> pre   |   | (see below)
      \    |        |          |
  ----------------------------------------
  Case 4:  |        |          |   ^
     |     | - in   |  - post  |   | (see below)
     *     |        |          |
  ----------------------------------------
  When going up, the next state is computed as follows.
    if the current node is a left child, then the next state is "in",
    otherwise the next state is "post".

  Let tree_step(state, n) be the function that implements
  the above transition diagram.
  Then we can implement a tree_walk as follows.

  def in_order_tree_walk_parent(T, action):
      if not T.root:
          return
      x = T.root
      state = 'pre'
      action(state, x.key)
      while not (x == T.root and state == 'post'):
          (state,x) = tree_step(state, x)
          if state == 'in':
              print(x.key)

  **** Student group work: implement tree_step.
