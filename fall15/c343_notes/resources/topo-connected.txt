Lecture: Topological Sorting and Connected Components
============================================================================

* Topological sorting

  (a) zig.cpp
  (b) boz.h
  (c) zag.cpp
  (d) zig.o
  (e) zag.o
  (f) libzigzag.a

   a  b  c
    \ |  |
     \|  |
      d  e
       \ |
        \|
         f

  - Is this a well-formed dependence graph, are there any cycles?
  - In what order should they be compiled?
  - How many steps are required to compile everything in parallel?

  - Recall that a topological ordering is an ordering of the
    vertices v_i such that

    If v_i -> v_j, then i < j.

    In other words, a vertex needs to come before every other vertex
    that depends on it.

    Here are many (all?) of the topological orderings:

    a,b, c, d,e, f
    b,a, c, d,e, f
    a,b, c, e,d, f
    b,a, c, e,d, f
    a,b, d, c,e, f
    b,a, d, c,e, f
    c,e, a,b, d, f
    c,e, b,a, d, f

* Knuth's algorithm for topological sort

      def topo_sort(successors, zeroes):
          # compute the in-degree of each vertex
          num_pred = [0 for k in range(0, len(successors))]
          for succs in successors:
              for v in succs:
                  num_pred[v] += 1

          # collect the vertices with zero in-degree
          for v in range(0, len(successors)):
              if num_pred[v] == 0:
                  zeroes.insert(v)

          # The main loop yields a vertex with zero in-degree and subtracts
          # one from the in-degree of each of its successors, adding them to
          # the zeroes bag when they reach zero.
          while not zeroes.is_empty():
              u = zeroes.remove_one()
              yield u
              for v in successors[u]:
                  num_pred[v] -= 1
                  if num_pred[v] == 0:
                      zeroes.insert(v)


  - Time Complexity of Topological Sort (Knuth's version)

    1. compute in-degrees
       Outer loop processes every vertex O(n)
       Outer + inner loop processes every edge O(m)
       Total: O(n + m)
       
    2. collect vertices with zero in-degree
       O(n)

    3. Main loops (while + for) processes each edge just once.
       O(m)

    Total: O(n + m) or because m is O(n^2), total is O(n^2)


 * What's the relationship between topological ordering and depth-first
    search? Let's look at the depth-first forest and discover/finish
    times of this graph.

     1/6 7/8 9/12
       a  b  c
        \ |  |
         \|  |
      2/5 d  e 10/11
           \ |
            \|
             f 3/4
 
    Here's the vertices ordered by finish time:
    f,d,a,b,e,c

    that's the reverse of one of the topological orders:
    c,e,b,a,d,f

    Why is that? A vertex is finished *after* every vertex that depends
    on it is finished. That's the same as topological ordering
    except we've swapped *before* for *after*.

* Incremental Connected Components (Ch. 21)

  Def. A connected component is a maximal subset of
    vertices C in an undirected graph such that
    for every u and v in C, u~>v.

  - Suppose the graph keeps changing, with additional edges, and we need to
    continuously keep track of the connected components.

  - The algorithm for connected components is straightforward
    to expressing using disjoint sets.

    # 1. put every vertex in a partition by itself
    ds = DisjointSet()
    for v in g.vertices():
       ds.make_set(v)

    # 2. union partitions that have an edge between them
    for (u,v) in g.edges():
       if ds.find_set(u) != ds.find_set(v):
          ds.union(u,v)

    # 3. collect up the answer into a dictionary keyed by representative
    # This step is not always necessary.
    P = {}
    for v in g.vertices():
       if ds.find(v) is v:
          P[v] = []
    for v in g.vertices():
       r = ds.find(v)
       if not r is v:
          P[r].append(v)

  - When another edge (u,v) is added to the graph,
    simply call ds.union(u,v).

  - You can determine which component a vertex v is in by
    calling ds.find_set(v).

  Example:

    a--b   e--f  h   j
    | /|   |     |
    |/ |   |     |
    c--d   g     j

    initial partitions  {a} {b} {c} {d} {e} {f} {g} {h} {i} {j}
     edge processed
     (b,d)              {a} {b,d} {c} {e} {f} {g} {h} {i} {j}
     (e,g)              {a} {b,d} {c} {e,g} {f} {h} {i} {j}
     (a,c)              {a,c} {b,d} {e,g} {f} {h} {i} {j}
     (h,i)              {a,c} {b,d} {e,g} {f} {h,i} {j}
     (a,b)              {a,c,b,d} {e,g} {f} {h,i} {j}
     (e,f)              {a,c,b,d} {e,g,f} {h,i} {j}
     (b,c)              {a,c,b,d} {e,g,f} {h,i} {j}

  - Time complexity:  (n vertices, m edges)
    All the work is in the union-find operations, so let's count those.
    1. n calls to make_set
    2. m calls to union
    3. 2n calls to find

    The time complexity for (3n + m) union-find operations is
    O((3n+m) alpha(n)) = O((n + m) alpha(n)).

  **** student group work: implement connected components.
