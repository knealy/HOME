Lecture: Heaps
==============

 * Motivations:
   1. We want a data structure that returns the maximum-keyed element of a set.
      This let's us represent a priority queue. The key's are the
      priorities.
      (AVL tree is an alternative. But we want to be more space efficient.) 
   2. Want to do in-place sorting in O(n lg n).
   3. Want to be able to change the key (priority) associated with an element.

 * Heaps
           ___16___
          /        \
        14          10
       /  \        /  \
      /    \      /    \
     8      7    9      3
    / \    /
   2   4  1

   Store in an array left-to-right, one level at a time,
   top-to-bottom.

     0  1  2  3  4  5  6  7  8  9 
   [16,14,10, 8, 7, 9, 3, 2, 4, 1]

  Def. A *heap* is an array viewed as a nearly complete binary tree.
    Given an array A, the root of the tree is stored at A[0] and for a
    node stored at index i, the left child is stored at index 2i+1 and
    the right child is stored at index 2(i+1).
    (Not to be confused with the use of "heap" to mean a computer's
    main memory.)
  
  Def. A *max heap* is a heap in which for every node other than the root, 
     A[i] <= A[parent(i)]

  This is called the "heap property" or "max-heap property".
  One can instead create a min-heap by flipping this around.

  parent(i) = floor((i-1)/2).

  * Overview of the Heap operations
    * build_max_heap creates a heap from an unordered array in O(n).
    * heap_sort sorts an array in-place in O(n lg n).
    * heap_maximum returns maximum element in O(1).
    * heap_insert adds a new element to a heap in O(lg n).
    * heap_extract_max removes the max in O(lg n).
    * heap_increase_key updates the key of an element in the heap in O(lg n).

  * max_heapify(H, i)

    Many of the heap operations need to turn an array that is almost a max
    heap, except for one element, into a max heap. The max_heapify
    operation moves the element at position i into the correct position.

    The tree rooted at i is not a max heap, but the subtrees
    left(i) and right(i) are max heaps.

    Example: 4 is greater than one of its children so we swap it with
    the larger child and repeat.

             ___16___
            /        \
          *4*         10
         /  \        /  \
        /    \      9    3
       14      7
      / \    /
     2   8  1

             ___16___
            /        \
          14          10
         /  \        /  \
        /    \      9    3
      *4*     7
      / \    /
     2   8  1

             ___16___
            /        \
          14          10
         /  \        /  \
        /    \      9    3
       8      7
      / \    /
     2  *4* 1

  
  **** Student group project: write the code for max_heapify(H, i, n)
     where n is the heap size
  solution:

      def max_heapify(H, i, n):
          l = left(i)
          r = right(i)
          # determine which of i, l, or r is the largest
          if l < n and H[i] < H[l]:
              largest = l
          else:
              largest = i
          if r < n and H[largest] < H[r]:
              largest = r
          # if i is not the largest, swap it with the largest,
          # then continuing max_heapify
          if largest != i:
              swap(H, i, largest)
              max_heapify(H, largest, n)

  * What is the time complexity of max_heapify? O(lg n)
  
  * build_max_heap(A)

    def build_max_heap(H):
        n = len(H)
        last_parent = n / 2 - 1
        for i in range(last_parent, -1, -1):
            max_heapify(H, i, n)

    Why does this procedure work? What is the loop invariant?
    Answer: the invariant is that the trees rooted at
      positions from i+1 to the end are max heaps.
    
    What is the time complexity?
    Answer: O(n lg n) is the easy answer, but not tight. 
       The tight upper bound is O(n).

       Observe that for an n-element heap, there are at most
       (n / n^{h+1}) nodes for each height h:
       Height 0 = n / 2     =  n / 2^{0+1}
       Height 1 = n / 4     =  n / 2^{1+1}
       Height 2 = n / 8     =  n / 2^{2+1}

       So we can sum these up, from h=0 to lg n, with O(h) cost for each:
       sum_{h=0}^{lg n} (n / 2^{h+1}) O(h)
       = O( n sum_{h=0}^{lg n} h / 2^h )
       recall A.8: 
          sum_{k=0}^{infty} k x^k = x / (1 - x)^2, for |x| < 1
          let x = 1/2:
          sum_{k=0}^{infty} k (1/2)^k = (1/2) / (1 - (1/2))^2
          = sum_{k=0}^{infty} k/(2^k) = (1/2) / (1/4) = 2
       so we get
        sum_{h=0}^{lg n} h / 2^h  < 2
       Thus
         O( n sum_{h=0}^{lg n} h / 2^h )
       = O( n 2 )
       = O(n)


  * heap_sort(H)

    Idea: move the max (the root) to the back, then shrink the heap by 1.

    def heap_sort(H):
        build_max_heap(H)
        for i in range(len(H.data) - 1, 0, -1):
            swap(H.data, 0, i)
            H.heap_size -= 1
            max_heapify(H, 0)

    Time complexity
      The for loop executes n times, and max_heapify is O(lg n),
      so we have O(n lg n).

  * extract_max
    Idea: first record the max, which is at H[0], then we need to delete
      that element. But deleting the first element of an array
      is expensive. So we move the last element of the heap
      to H[0] and then decrement the heap_size.
      
    def extract_max(H, n):
        assert n != 0
        max = H[0]
        H[0] = H[n-1]
        max_heapify(H, 0, n - 1)
        return max

  * heap_increase_key(H, i)
    The key of the object at position i has increased.
    How should we move it to get a valid heap?
    Example: Change the key of 9 to 20.

             ___16___
            /        \
          14          10
         /  \        /  \
        8    7     *9*    3

    **** Student group work, come up with the algorithm for increase_key        
    Answer: the idea is to propagate the element up

             ___16___
            /        \
          14          20
         /  \        /  \
        8    7      10    3

             ___20___
            /        \
          14          16
         /  \        /  \
        8    7      10    3

  * The Heap class: parameterize less-than, update positions.
    Need positions so we can efficiently do an increase key operation
    given an object in the heap.

    class Heap:
       def __init__(self, data, 
                    less = less,
                    update = ignore_update):
           self.data = data
           self.less = less
           self.update = update # needed for priority queues
           i = 0
           for obj in self.data:
               self.update(obj, i)
               i += 1
           build_max_heap(self.data)

       Need to change our heap operations to invoke
       H.update(H.data[i], i)
       whenever we move an element to a new position i.

      def less(x, y):
          return x < y

      def ignore_update(obj, pos):
          pass

  * Priority Queues
    - elements are objects with a key and position field
    - push
    - pop
    - increase_key notifies the queue that the key has increased

    def less_key(x, y):
        return x.key < y.key

    def update_position(obj, pos):
        obj.position = pos

    class PriorityQueue:
        def __init__(self):
            self.heap = Heap([], less=less_key, update=update_position)
        def push(self, obj):
            self.heap.insert(obj)
        def pop(self):
            return self.heap.extract_max()
        def increase_key(self, obj):
            heap_increase_key(self.heap, obj.position)
