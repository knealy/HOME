Lecture: Graphs
================================================================================

* The standard mathematical way to represent a graph G is with a set
  of vertices V and a set of edges E, that is, G = (V,E).

  In a *directed graph*, each edge is a pair of vertices where the
  first vertex is called the source and the second is the target.

  In an *undirected graph*, each edge is a set containing two 
  distinct vertices.
  I often use n for |V| and m for |E|.

  Example of a directed graph:
     ({1,2,3,4,5,6},
      {(1,2),(1,4),  (2,5),  (3,5),(3,6),  (4,2),  (5,4),  (6,6)})

     1-->2  3
     | ^ | /|
     V/  VV V
     4<--5  6<|
            |_|

  Given edge (u,v) in a directed graph, we say v is *adjacent* to v.
  The edge (u,v) is an *out-edge* of u and an *in-edge* of v.
  The *out-degree* of a vertex is the number of its out-edges.
  The *in-degree* of a vertex is the number of its in-edges.

  Example of undirected graph:
     ({1,2,3,4,5},
      {{1,2},{1,5},  {2,3},{2,4},{2,5},  {3,4},  {4,5}})

     1---2
     |  /| \
     | / |  3
     |/  | /
     5---4

    (We often writes edges as (1,2) instead of {1,2}.)

  Given edge {u,v} in an undirected graph, we say u and v are
  *adjacent* to each other. 
  We say that edge {u,v} is *incident on* vertex u and v.
  The *degree* of a vertex is the number of edges incident on it.

* The *Adjacency List* representation of a graph
  is an array of linked lists.

  Example, for the following directed graph (same as above).
     1-->2  3
     | ^ | /|
     V/  VV V
     4<--5  6<|
            |_|

     |1| -> 2 -> 4
     |2| -> 5
     |3| -> 6 -> 5
     |4| -> 2
     |5| -> 4
     |6| -> 6

  Example, for the following undirected graph (same as above)
  Note that each edge is stored twice.

     1---2
     |  /| \
     | / |  3
     |/  | /
     5---4

     |1| -> 5 -> 2
     |2| -> 1 -> 4 -> 3 -> 5
     |3| -> 2 -> 4
     |4| -> 5 -> 3 -> 2
     |5| -> 1 -> 2 -> 4

  Adjacency lists are good for storing sparse graphs.
  Space: O(n + m).
  Edge detection given two vertices: O(n)
  Edge insert: O(1)
  Edge removal given two vertices: O(n) 
  Edge remove given edge handle: O(1) if use double linked
  Edge removal: O(n) or O(1) if use double linked and edge handle
  Vertex insert: amortized O(1)
  Vertex delete: not easily supported

  **** Student group work:
    How could we represent Adjacency Lists for directed graphs in Python?

    class Edge:
       def __init__(self, src, tgt):
         self.source = src
         self.target = tgt

    class DirectedAdjList:
       def __init__(self, num_vertices):
          ...
       def add_edge(self, u, v):
          ...
       def out_edges(self, u):
         # return the list of edges whose source is vertex u
          ...

   What would change for undirected graphs?
  
* The *Adjacency Matrix* representation of a graph
  is a Boolean matrix.

  Example, for the directed graph above.

     1 2 3 4 5 6
   1 0 1 0 1 0 0
   2 0 0 0 0 1 0
   3 0 0 0 0 1 1
   4 0 1 0 0 0 0
   5 0 0 0 1 0 0
   6 0 0 0 0 0 1

  Example, for the undirected graph above.

     1 2 3 4 5
   1 0 1 0 0 1
   2 1 0 1 1 1
   3 0 1 0 1 0
   4 0 1 1 0 1
   5 1 1 0 1 0

  Note that the matrix is symmetric.

  Adjacency matrices are good for dense graphs.
  Space: O(n^2)
  Edge detection given two vertices: O(1)
  Edge insert: O(1)
  Edge removal given two vertices: O(1) 
  Edge remove given edge handle: O(1)
  Edge removal: O(1)
  Vertex insert: amortized O(1)
  Vertex delete: not easily supported

  How could we represent Adjacency Matrices in Python?
